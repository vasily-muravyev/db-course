### Задание 1
> Пусть в таблице users поля created_at и updated_at оказались незаполненными. 
> Заполните их текущими датой и временем.

```mysql

-- autogenerated code from alter table menu in MySQL Workbench
-- add columns created_at and updated_at with NULL value

/*
ALTER TABLE users
DROP COLUMN created_at;

ALTER TABLE users
DROP COLUMN updated_at;
*/

-- специльно используем тип VARCHAR вместо DATETIME для того чтобы поправить во втором задании
ALTER TABLE users
ADD COLUMN created_at VARCHAR(45) NULL DEFAULT NULL AFTER password_hash,
ADD COLUMN updated_at VARCHAR(45) NULL DEFAULT NULL AFTER created_at;

UPDATE users
SET
    created_at = NOW(),
    updated_at = NOW();
    
DESCRIBE users;
```

### Задание 2
>	Таблица users была неудачно спроектирована.
>    Записи created_at и updated_at были заданы типом VARCHAR и в них долгое время помещались значения в формате 20.10.2017 8:10. 
>    Необходимо преобразовать поля к типу DATETIME, сохранив введённые ранее значения.

```mysql
-- Первым делом приведем данные к неправильному формату (то есть создадим искуственно неправильные данные) - для того чтобы мы могли проверить обратную операцию
-- Используем для этого функцию DATE_FORMAT приводящую данные из правильного формата в тот что по условию задания

SET @conv_date_format = "%d.%m.%Y %l:%i";

UPDATE users
SET
    created_at = DATE_FORMAT(created_at, @conv_date_format),
    updated_at = DATE_FORMAT(updated_at, @conv_date_format);
    
-- Далее выполним задание используя обратную функцию STR_TO_DATE

UPDATE users
SET
    created_at = STR_TO_DATE(created_at, @conv_date_format),
    updated_at = STR_TO_DATE(updated_at, @conv_date_format);
    
-- поменяем тип колонки при помощи меню alter table в MySQL Workbench (ниже автосгенерированный код)
ALTER TABLE vk.users 
CHANGE COLUMN created_at created_at DATETIME NULL DEFAULT NULL ,
CHANGE COLUMN updated_at updated_at DATETIME NULL DEFAULT NULL ;


SELECT * FROM users;
```

### Задание 3
> В таблице складских запасов storehouses_products в поле value могут встречаться
> самые разные цифры: 0, если товар закончился и выше нуля, если на складе имеются запасы. 
>    Необходимо отсортировать записи таким образом, чтобы они выводились в порядке увеличения
>    значения value. Однако нулевые запасы должны выводиться в конце, после всех

-- таблицу storehouses_products заполнил при помощи сайта filldb.info
-- занулим 20% значений value для эксперимента

```mysql
UPDATE shop.storehouses_products
SET
    value = 0
WHERE
    id % 5 = 0;

-- теперь мы должны отсортировать в порядке увелчиния value, но 0 поместить в конце
-- для этого введем виртуальную булеву колонку в начале при помощи вычисления value = 0
-- вторым полем поместим само значение value

SELECT
    *
FROM 
    shop.storehouses_products
ORDER BY
    value = 0, value;
```


### Задание 4
> (по желанию) Из таблицы users необходимо извлечь пользователей,
>    родившихся в августе и мае. Месяцы заданы в виде списка английских названий (may, august)

```mysql
SELECT 
    *
FROM
    shop.users
WHERE
    MONTHNAME(birthday_at) IN ('May', 'August');
```

### Задание 5

> (по желанию) Из таблицы catalogs извлекаются записи при помощи запроса.
    
```mysql
SELECT 
    * 
FROM
    catalogs
WHERE
    id IN (5, 1, 2); 
```
>Отсортируйте записи в порядке, заданном в списке IN.

```mysql
SELECT
    *
FROM
    shop.catalogs
WHERE
    id IN (5, 1, 2)
ORDER BY
    FIELD(id, 5, 1, 2);
```

### Задание 6
> Подсчитайте средний возраст пользователей в таблице users.

```mysql
SELECT
    AVG(TIMESTAMPDIFF(YEAR, DATE(birthday_at),  DATE(NOW())))
FROM
    shop.users;
```

### Задание 7

> Подсчитайте количество дней рождения, которые приходятся на каждый из дней недели.
> Следует учесть, что необходимы дни недели текущего года, а не года рождения.

```mysql
SELECT
    DAYNAME(CONCAT(YEAR(NOW()), RIGHT(birthday_at, 6))) AS day_name,
    COUNT(*) as count
FROM
    shop.users
GROUP BY
    day_name
```

### Задание 8
> (по желанию) Подсчитайте произведение чисел в столбце таблицы.

```mysql
-- для примера посчитаем произведение столбца multiplier в таблице catalogs (добавил его через workbench)
-- сначала проверим есть ли в таблице 0

SET @has_zero_value = 
    (SELECT
        COUNT(multiplier)
    FROM
        shop.catalogs
    WHERE
    multiplier = 0);
        
-- SELECT @has_zero_value;
        
-- функции product() в mysql нет, поэтому вычислять будем по идее от Harold Fuchs
-- логарифм произведения равен сумме логарифмов и произведение показательных функций с одним основанием позволяет сложить степени
-- поэтому exp(sum(ln(...))) = произведению
-- для нашего случая будем считать что числа неотрицательны (если они будут отрицательны надо дополнительно посчитать четность отрицательных чисел)
-- и умножить на -1 если число отрицательных чисел нечетно

SET @product = IF(@has_zero_value,
                  0, 
                  (SELECT 
                          EXP(SUM(LN(multiplier)))
                  FROM
                       shop.catalogs));
SELECT @product;
```